// Code generated by mykit. DO NOT EDIT.
// Version {{ .Version }}

package server

import (
	"context"
	"fmt"
	"net"
	"os"
	{{- if .GenOpts.Profiling.Enable }}
	"net/http"
	"log"
	_ "net/http/pprof"
	{{- end }}
	{{ "\n" }}

	{{- if .GenOpts.GrpcLog.Enable }}
	"go.uber.org/zap/zapcore"
	"google.golang.org/grpc/codes"
	grpczap "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap/ctxzap"
	{{- end }}
	grpcctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
	"github.com/DataDog/datadog-go/statsd"
	"google.golang.org/grpc/metadata"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	mykit "{{ .MyKitBase }}/pkg/api"
	config "github.com/ChisTrun/carbon/pkg/config"
	"github.com/ChisTrun/logger/pkg/logging"
	"google.golang.org/grpc/health"
	healthv1 "google.golang.org/grpc/health/grpc_health_v1"
	"gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
	grpctrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/google.golang.org/grpc"
	{{ "\n" }}

	conf "{{ .Package }}/{{ .GoConfigPath }}"
)

func Run(f *config.Flags) {
	cfg := loadConfig(f)

	tracer.Start()
	defer tracer.Stop()

	{{ if .GenOpts.Profiling.Enable }}
	go func() {
		fmt.Println(http.ListenAndServe("0.0.0.0:{{ .GenOpts.Profiling.Port }}", nil))
	}()
	{{ end }}

	{{- if .GenOpts.AllowCustomOptions }}
	Serve(cfg)
	{{- else }}
	service := newService(cfg)
	Serve(cfg, service)
	{{- end }}
}

{{- if .GenOpts.OpenMetrics.Enable }}
var serverMetrics *metrics.ServerMetrics
{{- end }}

func newService(cfg *conf.Config, opts ...mykit.Option) mykit.Service {
	statsd, err := statsd.New(os.Getenv("DOGSTATSD_HOST_IP") + ":8125")
	if err != nil {
		logging.NewTmpLogger().Error("fail to create datadog client", zap.Error(err))
	}
	statsd.Namespace = "gostatsd."

	err = logging.InitLogger(cfg.Logger)
	if err != nil {
		logging.NewTmpLogger().Error("fail to init logger", zap.Error(err))
	}


	listener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", cfg.Listener.GetTcp().Address, cfg.Listener.GetTcp().Port))
	if err != nil {
		logging.NewTmpLogger().Fatal("failed to new listener", zap.Error(err))
	}

	logger := logging.Logger(context.Background())
	{{- if .GenOpts.GrpcLog.Enable }}
	loggerOpts := []grpczap.Option{
        grpczap.WithMessageProducer(func(ctx context.Context, msg string, level zapcore.Level, code codes.Code, err error, duration zapcore.Field) {
            // re-extract logger from newCtx, as it may have extra fields that changed in the holder.
            ctxzap.Extract(ctx).Check(level, msg).Write(
                zap.Error(err),
                zap.String("grpc.code", code.String()),
                zap.String("x_request_id", GetRequestID(ctx)),
                duration,
            )
        }),
    }
	{{- end }}

	{{- if .GenOpts.OpenMetrics.Enable }}
	serverMetrics = metrics.NewServerMetrics(metrics.WithServerHandlingTimeHistogram())
	registry := prometheus.NewRegistry()
	{{- end }}

	healthServer := health.NewServer()
	healthServer.SetServingStatus("", healthv1.HealthCheckResponse_SERVING)

	defaultOpts := []mykit.Option{
		mykit.Stats(statsd),
		mykit.Logger(logger),
		mykit.Listener(listener),
		mykit.ServerOptions(
			grpc.ChainUnaryInterceptor(
				grpcctxtags.UnaryServerInterceptor(grpcctxtags.WithFieldExtractor(grpcctxtags.CodeGenRequestFieldExtractor)),
				{{- if .GenOpts.GrpcLog.Enable }}
				grpczap.UnaryServerInterceptor(logger, loggerOpts...),
				{{- end }}
				{{- if .GenOpts.OpenMetrics.Enable }}
				metrics.UnaryServerInterceptor(serverMetrics),
				{{- end }}
				grpctrace.UnaryServerInterceptor(grpctrace.WithUntracedMethods("/grpc.health.v1.Health/Check"), grpctrace.WithServiceName(os.Getenv("DD_SERVICE"))),
			),
		),
		mykit.HealthServer(healthServer),
		{{- if .GenOpts.OpenMetrics.Enable }}
		mykit.MetricRegistry(registry),
		{{- end }}
	}

	{{ if or .GenOpts.HttpServer.Enable }}
	httpListener, err := net.Listen("tcp", fmt.Sprintf("%s:%d", cfg.HttpListener.GetTcp().Address, cfg.HttpListener.GetTcp().Port))
	if err != nil {
		logging.NewTmpLogger().Fatal("failed to new http listener", zap.Error(err))
	}
	httpListenerOption := mykit.HttpListener(httpListener)
	defaultOpts = append(defaultOpts, httpListenerOption)
	{{ end }}


	svc := mykit.NewService(append(defaultOpts, opts...)...)
	{{- if .GenOpts.OpenMetrics.Enable }}
	svc.Init(mykit.BeforeStart(initOpenMetrics(s)))
	{{- end }}
	return svc
}

func GetRequestID(ctx context.Context) string {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return ""
	}
	mdUserID := md.Get("x-request-id")
	if len(mdUserID) < 1 {
		return ""
	}
	return mdUserID[0]
}

{{- if .GenOpts.OpenMetrics.Enable }}
func initOpenMetrics(s mykit.Service) func() error {
	return func() error {
        registry := s.MetricRegistry()
        serverMetrics.InitializeMetrics(s.Server())
        registry.Register(serverMetrics)
        http.Handle("{{ .GenOpts.OpenMetrics.Path }}", promhttp.HandlerFor(registry, promhttp.HandlerOpts{}))
        go http.ListenAndServe(":{{ .GenOpts.OpenMetrics.Port }}", nil)

        return nil
	}
}
{{- end }}

func loadConfig(f *config.Flags) *conf.Config {
	// Use a temporary logger to parse the configuration and output.
	tmpLogger := logging.NewTmpLogger().With(zap.String("filename", f.ConfigPath))

	var cfg conf.Config
	if err := config.ParseFile(f.ConfigPath, &cfg, f.Template); err != nil {
		tmpLogger.Fatal("parsing configuration failed", zap.Error(err))
	}

	if err := cfg.Validate(); err != nil {
		tmpLogger.Fatal("validating configuration failed", zap.Error(err))
	}

	if f.Validate {
		tmpLogger.Info("configuration validation was successful")
		os.Exit(0)
	}

	return &cfg
}
